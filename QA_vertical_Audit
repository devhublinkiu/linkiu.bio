- [ ] **Estructura de archivos:** Para garantizar el auto-descubrimiento de archivos y la escalabilidad, todo nuevo módulo debe adherirse estrictamente a la siguiente estructura física:

Capa Administrativa (Admin/Staff):
Backend: app/Http/Controllers/Tenant/Admin/[Modulo]/
Frontend: resources/js/Pages/Tenant/Admin/[Modulo]/
Capa Pública (Tenant/Customer):
Backend: app/Http/Controllers/Tenant/[Modulo]/
Frontend: resources/js/Pages/Tenant/[Modulo]/
Modelos y Datos:
Ubicación: app/Models/Tenant/[Modulo]/
Nomenclatura: Singular y PascalCase (ej: Product.php).
Componentes Locales:
Si un componente React es exclusivo del módulo y no será reutilizado globalmente, debe crearse una subcarpeta Components/ dentro de la ruta del frontend del módulo.
Validación de Identidad (Reflejo):
El namespace en archivos PHP y el alias de importación en JS deben coincidir exactamente con la jerarquía de carpetas.
Mandato: No se permite la creación de controladores o modelos en las carpetas raíz de Tenant o Admin. Todo debe estar agrupado por su nombre de módulo correspondiente."


- [ ] **Limpieza de carpetas:** "Un módulo debe ser un entorno productivo limpio y libre de ruido técnico. Para asegurar la calidad del código y la facilidad de mantenimiento, se establecen las siguientes restricciones de archivos:

Prohibición de Residuos: No se permite la permanencia de archivos temporales, de respaldo o copias de seguridad (ej: .bak, .old, .orig, Copy of..., Component_v2.tsx). El control de versiones debe delegarse exclusivamente a Git.
Aislamiento de Código de Desarrollo: Archivos de depuración, scripts de prueba rápidos (ej: debug.php, test-logic.js) o logs locales deben ser eliminados antes de cualquier commit o despliegue.
Estilos Globales: No se permite la creación de archivos de hojas de estilo locales (.css, .scss) dentro de las carpetas del módulo. Todo el diseño debe basarse en Tailwind CSS o componentes del sistema de diseño global de Linkiu.
Principio de Modularidad vs. Abstracción:
Si un archivo dentro del módulo es genérico y tiene potencial de uso en otros módulos, DEBE ser extraído a las carpetas globales correspondientes (app/Traits/Shared, resources/js/Components/ui).
Inversamente, el módulo no debe contener componentes globales que ya existan en la librería central del proyecto.
Mandato: Todo archivo presente en el módulo debe tener una función activa y única para la versión actual. Archivos 'huérfanos' o redundantes serán considerados deuda técnica inmediata."


- [ ] **Registro en directorio de modulos:**"Para que un módulo sea reconocido oficialmente por el ecosistema de Linkiu, debe estar registrado y documentado en el núcleo de la plataforma antes de su despliegue:

Carpeta de Especificación Técnica: Se debe crear un directorio con el nombre del módulo dentro de la vertical correspondiente en MODULOS_v2/[Vertical]/[NombreModulo]/.
Ficha de Especificación Automática (SPEC.md): Todo módulo debe contener un archivo SPEC.md dentro de su carpeta en MODULOS_v2/ que detalle:
Objetivo: Propósito funcional del módulo.
Modelos Clave: Entidades de base de datos involucradas.
Dependencias: Si requiere otros módulos o servicios externos (ej: WhatsApp, Pasarelas de Pago).
Vínculo al Mapa de Skills (SKILL_MAP.md): El módulo debe ser agregado al archivo SKILL_MAP.md de su vertical mediante un diagrama Mermaid y un enlace relativo al archivo SPEC.md. Esto garantiza que cualquier IA o desarrollador nuevo pueda mapear el sistema completo y las capacidades (skills) disponibles al instante.
Categorización por Vertical: Si el módulo es transversal (ej: Soporte, Usuarios), debe ubicarse bajo la vertical ALL_VERTICALS. Si es de nicho, debe ir estrictamente en su vertical (ej: V_GASTRONOMY).
Mandato: Un módulo sin registro en la carpeta MODULOS_v2/ o sin presencia en el SKILL_MAP.md se considera 'invisible' y no forma parte oficial de la plataforma."


- [ ] **Revision de logica:** "La lógica del módulo debe ser robusta, segura y fácil de mantener, siguiendo los principios de 'Fat Models, Skinny Controllers' y DRY (Don't Repeat Yourself):

Validación de Datos (FormRequests): No se permite la validación manual dentro de los métodos del controlador. Se deben utilizar clases FormRequest dedicadas para validar la entrada de datos antes de que lleguen a la lógica de negocio.
Manejo de Errores y Excepciones: Toda operación crítica (inserciones en BD, llamadas a APIs) debe estar envuelta en bloques try-catch. Los errores deben ser capturados y devueltos como respuestas JSON estandarizadas con códigos de estado HTTP correctos (ej: 422 para validación, 500 para fallos de sistema).
No-Duplicidad (Traits y Servicios): Si una lógica se repite o es compleja (ej: cálculos de impuestos, integraciones), debe abstraerse en un Trait o en una clase de Servicio. Los controladores solo deben orquestar la petición.
Tipado y Contratos (TS/PHP):
Backend: Usar type hinting en parámetros y retornos de funciones.
Frontend: Definir Interfaces o Types claros para todas las Props y Estados en React. Prohibido el uso de any.
Mandato: El código debe ser auto-descriptivo. Si un método requiere comentarios extensos para ser entendido, se considera una falla de arquitectura y debe ser refactorizado."


- [ ] **Revision de UX:** "El usuario debe percibir una interfaz fluida, profesional y viva. La omisión de feedback visual se considera un error de usabilidad:

Estados de Carga Proactivos: Todo proceso asíncrono o navegación que supere los 300ms de latencia DEBE mostrar un Skeleton (para contenedores de datos) o un Spinner (para acciones puntuales). No se permite el bloqueo de la UI sin una indicación visual de progreso.
Sistema de Notificaciones (Sonner): Cada acción crítica de escritura (crear, actualizar, eliminar) debe disparar una notificación mediante el componente Sonner. Los mensajes deben ser específicos al contexto (ej: "Precios de la carta actualizados" en lugar de "Guardado con éxito").
Micro-interacciones en Botones: Los botones de acción (Submit) deben reflejar un estado loading deshabilitado mientras se procesa la solicitud para evitar envíos duplicados y dar feedback táctil inmediato.
Diseño Adaptativo Nativo: El módulo debe ser funcional al 100% en dispositivos móviles y tablets. Se debe priorizar el uso de componentes responsivos (ej: Drawer en móvil vs. Modal en escritorio) donde la densidad de información lo requiera.
Manejo de Errores Amigable: Ante un error 422 o 500, el frontend debe traducir la respuesta técnica en un mensaje comprensible para el usuario, indicando qué falló y cómo corregirlo (si aplica).
Mandato: Si una acción del usuario no produce una respuesta visual inmediata (cambio de estado, notificación o loader), la implementación será rechazada por falta de estándares UX Premium."


- [ ] **Rendimiento de queries:** "La eficiencia en el manejo de datos es crítica para la escalabilidad. Una mala gestión de la base de datos degrada la experiencia premium de la plataforma:

Eliminación de Consultas N+1: Está estrictamente prohibido acceder a relaciones de Eloquent dentro de bucles (foreach) o directamente en las vistas de Inertia sin haber sido cargadas previamente. Se debe utilizar SIEMPRE el método with() (Eager Loading) en el controlador para hidratar todas las relaciones necesarias en una sola consulta SQL.
Carga Selectiva de Columnas: Evitar el uso de select * en tablas con alta densidad de datos o campos pesados (ej: JSON, TEXT). Se debe priorizar el uso de select(['id', 'name', ...]) para minimizar el consumo de memoria del servidor y el peso del payload JSON enviado al frontend.
Paginación Obligatoria: No se permite el uso de 
get()
 o all() en listados que puedan crecer indefinidamente (pedidos, clientes, productos). Se debe implementar el método paginate() de Laravel para segmentar la carga de datos.
Aislamiento de Datos (Tenant & Sede): Toda consulta debe estar protegida por el contexto del Tenant actual. En el caso de listados administrativos, se debe incluir el filtro por location_id de forma nativa para garantizar que el staff solo opere sobre los datos de su sede asignada.
Mandato: Cualquier pantalla que dispare más de 15 consultas SQL para una carga estándar de datos será rechazada y requerirá una refactorización inmediata para optimizar el rendimiento."


- [ ] **Estados vacios:** "La ausencia de datos no debe significar una interfaz desértica. Un módulo profesional debe guiar al usuario incluso cuando no hay información disponible:

Componente Standard EmptyState: Es obligatorio el uso de un componente EmptyState dedicado que incluya:
Iconografía/Ilustración: Un refuerzo visual coherente con el propósito del módulo (ej: un icono de calendario para citas, o un carrito para pedidos).
Mensaje Descriptivo: Explicación clara de por qué el contenedor está vacío (ej: "Aún no tienes pedidos registrados este mes").
Acción Primordial (CTA): Si el flujo lo permite, incluir un botón que invite a crear el primer registro (ej: "Crear mi primer pedido").
Alcance Multicontenedor: Esta regla aplica a tablas, listados, tableros Kanban, galerías de archivos y cualquier sección de datos dinámicos.
Prohibición de Estructuras Huérfanas: No se permite mostrar cabeceras de tabla sin datos debajo o textos planos de sistema (ej: "no documentation found").
Mandato: Todo contenedor de datos debe manejar condicionalmente su estado vacío mediante un componente visual rico. El renderizado de una lista vacía sin su correspondiente EmptyState será considerado un error de diseño de interfaz."


- [ ] **Confirmación de acciones destructivas:** Definición de Implementación:

"La integridad de la información es una prioridad primordial. El sistema debe prevenir activamente errores accidentales del usuario mediante mecanismos de confirmación explícitos y estandarizados:

Uso Obligatorio de AlertDialog: Toda acción que resulte en la eliminación permanente, desactivación de un servicio crítico o cambio irreversible de estado de un registro DEBE estar precedida obligatoriamente por el componente AlertDialog de la plataforma.
Configuración Semántica del Diálogo:
Título: Debe ser directo y preguntar por la acción (ej: "¿Eliminar este registro?").
Descripción: Debe explicar claramente las consecuencias (ej: "Esta acción no se puede deshacer. Los datos relacionados también podrían verse afectados").
Botón de Confirmación: Debe utilizar la variante visual destructive (color de alerta/rojo) para señalizar el riesgo de la operación.
Bloqueo de Re-ejecución: El botón de confirmación dentro del diálogo debe mostrar un estado de carga (loading) y quedar deshabilitado mientras se espera la respuesta del servidor para evitar peticiones duplicadas.
Prohibición de Diálogos Nativos: Está estrictamente prohibido el uso de window.confirm() o alert() nativos del navegador. Toda interacción debe ocurrir dentro del ecosistema de componentes de Linkiu para mantener la estética premium.
Mandato: Cualquier proceso de borrado o alteración crítica de datos que se ejecute directamente tras un clic sin mediar un AlertDialog será catalogado como una falla de seguridad funcional."


- [ ] **Notificaciones (Sonner):** "Para garantizar que el usuario mantenga siempre el control sobre sus acciones, todo flujo de escritura o alteración de datos debe concluir con una confirmación visual explícita:

Uso Estandarizado de Sonner: Toda respuesta exitosa (200/201 OK) o error de sistema (500) derivado de una acción del usuario (Crear, Editar, Eliminar, Cambiar Estado) DEBE comunicarse mediante el componente Sonner.
Configuración de Visualización: Las notificaciones deben posicionarse obligatoriamente en bottom-center para garantizar la máxima visibilidad en dispositivos móviles y escritorio, manteniendo la coherencia visual en toda la plataforma.
Contenido Semántico y Específico:
Confirmación de Éxito: El mensaje debe ser breve pero descriptivo de la entidad afectada (ej: "Mesa [A1] liberada" es preferible a "Operación exitosa").
Alertas de Error: Si la operación falla, se debe usar la variante de error del toast, indicando de forma clara que el proceso no se completó.
Integración con el Ciclo de Vida de Inertia: La notificación debe dispararse en los callbacks onSuccess u onError de las peticiones de formulario, asegurando que el feedback coincida con la realidad del servidor.
Variantes de Estado: Es obligatorio el uso de toast.success() para resultados positivos y toast.error() para fallos, respetando el código de colores y la iconografía del sistema de diseño.
Mandato: Las acciones 'silenciosas' están prohibidas. Cualquier interacción que altere la base de datos sin disparar un feedback visual de confirmación será rechazada por falta de estándar comunicacional."


- [ ] **Responsividad:** "Linkiu debe ser una herramienta de trabajo ágil en cualquier dispositivo. La experiencia en móviles y tablets no es una adaptación secundaria, sino un requisito de diseño nativo desde el inicio:

Ubicación y Breakpoints: Se debe utilizar estrictamente el sistema de breakpoints de Tailwind CSS (sm:, md:, lg:, xl:) para ajustar el layout. Se prohíben los anchos fijos en píxeles (px) que rompan el contenedor en pantallas pequeñas.
Jerarquía de Componentes por Dispositivo:
Descritorio (lg/xl): Uso de Modales y tablas densas con múltiples columnas.
Móvil/Tablet (sm/md): Priorizar el uso de Drawers (hojas laterales/inferiores) para formularios y transformar tablas en Cards o listados simplificados si la legibilidad es comprometida.
Manejo de Desbordamiento (Overflow): Todo contenedor de datos anchos (como tablas o gráficos) debe implementar scroll horizontal contenido o envolverse en componentes que prevengan el desbordamiento lateral del viewport global.
Optimización Táctil (Touch Targets): Los elementos interactivos (botones, inputs, toggles) deben tener un área de clic/toque mínima adecuada para dedos (mínimo 44px de altura/anchura) para evitar errores de interacción en móviles.
Visibilidad Selectiva: Utilizar las clases hidden y block/flex con modificadores de pantalla para ocultar elementos no esenciales en móvil y así priorizar la información más importante para el usuario en movimiento.
Mandato: Un módulo que presente barras de scroll horizontal en el cuerpo de la página o elementos que se 'corten' visualmente en resoluciones de móvil (375px a 768px) será rechazado automáticamente."


- [ ] **Acceso desde sidebar:** "El acceso al módulo debe estar perfectamente integrado en el sistema de navegación global, respetando la jerarquía y los permisos del usuario de forma dinámica:

Registro en Navegación Centralizada: El nuevo componente o página DEBE ser registrado en la configuración de menús (ej: 
menuConfig.ts
 o el archivo de configuración del sidebar correspondiente). No se permiten accesos por URL directa sin su representación visual en el menú si el módulo es de gestión administrativa.
Visibilidad Basada en Permisos (RBAC): El ítem del menú debe estar envuelto en una lógica de validación de permisos. Si el usuario no tiene la capacidad técnica de acceder, el ítem debe ocultarse o mostrar un estado restringido (ej: candado rojo o badge PRO) según el estándar definido de la plataforma.
Lógica de Estado Activo: El ítem del sidebar debe detectar automáticamente cuando el usuario se encuentra dentro de sus rutas o sub-rutas. Se debe asegurar que el resaltado visual (active state) se mantenga activo mientras se navega por cualquier sub-página que pertenezca funcionalmente al módulo.
Categorización y Orden: El ítem debe ubicarse en la sección/grupo correspondiente a su vertical de negocio. Se debe asignar un peso u orden numérico coherente para evitar desplazamientos aleatorios de los elementos en el menú.
Iconografía Coherente: Se debe utilizar un icono que represente fielmente la función del módulo, extraído de la librería estándar del proyecto (ej: Lucide React), manteniendo la consistencia de estilo y tamaño con el resto del menú lateral.
Mandato: Un módulo 'huérfano' (sin acceso visible desde el sidebar para el rol administrativo correspondiente) se considera una falla grave de integración y flujo de usuario."


- [ ] **Paginación:** "Para asegurar un rendimiento óptimo y una experiencia de usuario sin fricciones en listados de gran volumen, se deben seguir estos estándares de segmentación de datos:

Segmentación en Servidor (Laravel Pagination): Todo listado que gestione entidades con potencial de crecimiento (ej: Pedidos, Clientes, Logins) DEBE utilizar el método paginate() o simplePaginate() de Eloquent. Queda estrictamente prohibido el uso de get() o all() en controladores de listado.
Sincronización con Inertia.js: Los datos paginados deben enviarse al frontend respetando la estructura de objeto de paginación de Laravel (data, links, meta, etc.) para permitir la navegación reactiva sin recargas de página completas.
Componente de Navegación Estándar: El frontend debe implementar un componente de paginación consistente (ej: Pagination.tsx) que permita al usuario saltar entre páginas, ver el estado actual y navegar hacia adelante/atrás de forma intuitiva.
Preservación de Estado (State Preservation): Al cambiar de página, se debe utilizar la opción preserveScroll: true y preserveState: true de los enlaces de Inertia para evitar que el usuario pierda su posición visual o filtros activos en la pantalla.
Feedback de Transición: Durante el cambio de página, se debe mostrar un indicador de carga sutil (ej: un loader sobre el listado o una barra de progreso superior) si la latencia de la red es perceptible.
Mandato: Cualquier módulo que intente cargar más de 100 registros en una sola petición sin un mecanismo de paginación será rechazado por riesgo de inestabilidad y degradación del rendimiento."


- [ ] **Seguridad de rutas:** "La seguridad de Linkiu se basa en capas concéntricas de protección. Las rutas son la primera línea de defensa y deben estar configuradas para prevenir cualquier acceso no autorizado o fuga de datos entre inquilinos (tenants):

Middleware Mandatorio de Inquilino: Toda ruta que maneje datos de un cliente DEBE estar envuelta en el middleware de tenant. Esto garantiza que el sistema identifique y cargue correctamente el contexto de la base de datos del inquilino correspondiente antes de ejecutar cualquier lógica.
Protección de Identidad (Middleware Auth):
Rutas Administrativas: Deben estar protegidas por auth:sanctum (para API) o auth (web) para asegurar que solo usuarios autenticados operen el sistema.
Rutas Públicas: Deben estar claramente identificadas y limitadas al mínimo necesario para el funcionamiento del front-end del cliente.
Agrupación Jerárquica de Rutas: Las rutas deben organizarse en grupos descriptivos dentro de 
routes/web.php
 o routes/api.php, utilizando prefijos y nombres de ruta consistentes (ej: Route::prefix('admin/gastronomy')->name('tenant.admin.gastronomy.')...).
Validación de Salida (API Security): Las rutas de API deben implementar protección contra ataques de fuerza bruta y rate-limiting si exponen funcionalidades críticas (login, registros, pagos).
Aislamiento de Recursos: Queda estrictamente prohibido definir rutas que permitan el acceso a IDs de recursos mediante parámetros de URL sin una validación posterior en el controlador que asegure que el recurso pertenece efectivamente al tenant_id y/o location_id del usuario.
Mandato: No se permite la existencia de rutas 'huérfanas' o fuera de middlewares de protección. Cualquier ruta que exponga datos sensibles sin validación de inquilino o sesión será considerada una vulnerabilidad crítica."


- [ ] **Restricción de Permisos (Sidebar UX):** "La experiencia de usuario debe ser transparente respecto a sus capacidades dentro de la plataforma. El acceso restringido debe manejarse de forma elegante en el frontend para evitar frustraciones y errores técnicos inesperados:

Indicador Visual de Restricción: Si un usuario tiene el módulo visible en su sidebar pero carece del permiso de 'ver' (view), el ítem de navegación DEBE mostrar un candado rojo junto al nombre o icono del módulo.
Prevención de Errores 403 (Forbidden): Se debe evitar que el usuario llegue a una pantalla de error del servidor. En lugar de permitir la navegación y disparar un 403, el clic en un ítem restringido debe estar interceptado en el frontend.
Llamada a la Acción (PermissionDeniedModal): Al hacer clic en un elemento con acceso restringido, el sistema debe disparar automáticamente el componente PermissionDeniedModal. Este modal debe informar al usuario que no tiene los permisos suficientes y sugerir contactar con el administrador.
Sincronización con el Backend (Can Prop): La visibilidad y el estado del candado deben depender directamente de la propiedad can enviada desde el backend a través de Inertia, asegurando que el frontend refleje fielmente los permisos reales del usuario.
Capa de Seguridad Triple:
Sidebar: Ocultar u bloquear el acceso visual.
Rutas: Middleware de protección.
Controlador: Gate::authorize() como última línea de defensa.
Mandato: Está prohibido mostrar errores 403 nativos de Laravel/Nginx al final de un flujo de navegación. Cualquier funcionalidad restringida que no dispare el PermissionDeniedModal será considerada un error de implementación de flujo de usuario."


- [ ] **Restricción de Plan (Sidebar UX):** "Para incentivar el crecimiento de los clientes (upselling) y mantener una navegación aspiracional, los módulos que no formen parte del plan contratado deben ser visibles pero estar claramente señalizados como funcionalidades de nivel superior:

Indicador de Nivel de Plan (Badge PRO): Si un módulo no está incluido en la suscripción actual del inquilino (tenant), el ítem de navegación DEBE mostrar un badge con el texto 'PRO' en color ámbar/dorado. Este badge reemplaza visualmente al candado de permisos para diferenciar una restricción de rol de una restricción de negocio.
Interceptación de Navegación Aspiracional: Al hacer clic en un módulo marcado como 'PRO', el frontend debe interceptar la acción y mostrar el componente UpgradePlanModal o PricingComparisonModal. Queda estrictamente prohibido redirigir al usuario a una página de error o a una pantalla en blanco.
Llamada a la Acción (CTA) de Upgrade: El modal de restricción de plan debe incluir información clara sobre qué plan contiene el módulo y un botón directo hacia la sección de facturación o contacto comercial para realizar el upgrade.
Validación Basada en Características (Feature Flags): La visibilidad del badge PRO debe depender del objeto features o plan_capabilities enviado desde el backend, asegurando que el estado del sidebar esté siempre sincronizado con los límites comerciales del inquilino.
Mandato: Está prohibido que un usuario descubra que un módulo no está en su plan mediante un mensaje de error post-clic. El estado comercial del módulo debe ser evidente desde el sidebar lateral mediante el sistema de badges PRO."


- [ ] **Aislamiento Estricto de Datos (Multi-Tenant Isolation):** "El aislamiento entre inquilinos es el pilar de la confianza y seguridad de Linkiu. Debe garantizarse por diseño que ningún inquilino (Tenant) pueda, bajo ninguna circunstancia, acceder, visualizar o inferir información perteneciente a otro inquilino o al SuperAdmin:

Filtrado Automático por tenant_id: Todos los modelos que contengan datos específicos de un cliente DEBEN utilizar el trait BelongsToTenant. Este trait aplica un Global Scope que añade automáticamente la condición WHERE tenant_id = current_tenant en cada consulta, evitando fugas de datos por olvido de filtrado manual.
Prevención de IDOR (Insecure Direct Object Reference): Está prohibido confiar ciegamente en los IDs recibidos por URL. Los controladores deben validar que cualquier registro solicitado pertenezca efectivamente al inquilino que realiza la petición (incluso si se usa el Global Scope, se recomienda una validación de propiedad explícita en acciones críticas).
Aislamiento del SuperAdmin: Los inquilinos no deben tener visibilidad ni acceso a tablas o configuraciones globales del sistema (Landlord/Central). La información de auditoría global, logs de sistema y metadatos de SuperAdmin debe residir en una capa o base de datos inaccesible para los inquilinos.
Limpieza de Sesiones y Contexto: El sistema de cambio de inquilino (si aplica para soporte) debe purgar completamente la memoria, caché y variables de sesión del contexto anterior antes de cargar el nuevo, asegurando que no existan remanentes de datos cruzados.
Cero Visibilidad Multitenant: Bajo ninguna condición un usuario de una sede o tenant 'A' podrá ejecutar una query o ver un reporte que incluya promedios, nombres o métricas de un tenant 'B', a menos que se trate de un rol global de SuperAdmin operando fuera del contexto de inquilino.
Mandato: Cualquier brecha que permita ver el ID o información de un tercero mediante la manipulación de parámetros (IDOR) será tratada como un fallo de seguridad crítico de nivel 1."

- [ ] **Aislamiento Estricto de Datos (Multi-Tenant Isolation):** "Linkiu admite un sistema de multisedes (sedes físicas independientes dentro de un mismo Tenant). Esta regla define cómo y cuándo aplicar el aislamiento por sede:

Evaluación de Aplicabilidad: El aislamiento por location_id no es universal para todos los módulos. Aplica principalmente en verticales operativas (ej: Gastronomía, Servicios con citas presenciales) y en módulos que gestionan recursos físicos (ej: Pedidos, Mesas, Inventario por sede, Reservas).
Protocolo de Duda (Consulta Obligatoria): Si el desarrollador (IA o humano) tiene la más mínima duda sobre si el módulo en desarrollo debe ser 'Location-Aware' (consciente de las sedes), DEBE detener la implementación y preguntar explícitamente al USER antes de crear las migraciones o controladores.
Filtrado de Datos por Sede: En los módulos que aplique, las consultas de base de datos deben ser filtradas por el location_id rescatado de la sesión del staff, de la mesa escaneada o del parámetro de contexto activo.
Integración en Modelos: Los modelos afectados deben incluir el campo location_id y estar preparados para relaciones de pertenencia a una sede específica.
Coherencia en UI/UX: La interfaz debe mostrar claramente en qué sede se están operando los datos si el usuario tiene acceso a múltiples ubicaciones.
Mandato: Implementar un módulo con location_id donde no se requiere, o ignorar el aislamiento por sede donde sí es necesario, será considerado un fallo de diseño lógico. En caso de duda: PREGUNTAR PRIMERO."

- [ ] **Estandarización de Idioma (Single Language):**"Para mantener la coherencia y profesionalismo en la plataforma, el idioma oficial y único de Linkiu es el Español.

Cero Spanglish: Queda estrictamente prohibido mezclar términos en inglés y español en la interfaz (ej: usar 'Save' y 'Cancelar' en el mismo formulario).
Validaciones y Mensajes: Todos los mensajes de error (backend y frontend) deben ser redactados en español claro y profesional.
Logs y Comentarios: Aunque el código técnico use estándares de industria (inglés para variables/funciones), todo lo que el usuario final pueda leer debe nacer en español.
Mandato: Cualquier componente o controlador que envíe strings en inglés al cliente será marcado como error de internacionalización."


- [ ] **Almacenamiento Exclusivo en Bunny.net (Cloud Storage Only):**"La gestión de archivos en Linkiu es 100% dependiente de la infraestructura de Bunny.net para garantizar velocidad y bajos costos:

Protocolo Bunny Obligatorio: Queda terminantemente prohibido el uso de almacenamiento local (Storage::disk('local')) o proveedores alternativos como AWS S3 o Google Cloud.
Integración Mediante Traits: Toda subida de archivos debe realizarse utilizando los métodos estandarizados en los Traits de almacenamiento del proyecto, asegurando que se respeten los prefijos de Tenant y las configuraciones de CDN.
Optimización Automática: Se debe configurar el envío a Bunny priorizando formatos de alto rendimiento (WebP) y redimensionamiento dinámico cuando sea posible.
Mandato: Cualquier implementación que guarde archivos en el servidor local o use servicios distintos a Bunny.net será considerada una falla crítica de infraestructura."


- [ ] **Sistema de UI y Componentes (Shadcn Only & Manual Approval):** "Para mantener la coherencia técnica y estética de Linkiu, se establece un ecosistema cerrado de componentes basado exclusivamente en Shadcn UI:

Uso Exclusivo de Shadcn: Solo se permite el uso de componentes que ya estén instalados en resources/js/Components/ui/ (basados en Shadcn).
Protocolo de Componente Faltante (Pause & Notify): Si para la implementación de una tarea se requiere un componente de Shadcn que AÚN NO ESTÁ en el proyecto, el desarrollador (IA o humano) DEBE:
PAUSAR la tarea inmediatamente.
NOTIFICAR al usuario sobre la necesidad del componente específico.
ESPERAR a que el usuario lo instale o dé la autorización expresa para proceder antes de continuar con el código.
Prohibición de Estilos Ad-hoc: No se permite crear recreaciones manuales de componentes complejos (ej: DatePickers, Selects, Modales) ni usar librerías externas. Si Shadcn tiene una solución, esa es la que se usa tras aprobación.
Mandato: Implementar lógica con componentes ajenos a Shadcn o instalar nuevos componentes sin aviso previo se considera una violación de la arquitectura de la interfaz. EN CASO DE DUDA O COMPONENTE FALTANTE: PARAR Y PREGUNTAR."
